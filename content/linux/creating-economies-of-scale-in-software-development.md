Title: Creating Economies of  Scale in Software Development
Date: 2012-07-29 04:39
Author: John Pfeiffer
Slug: creating-economies-of-scale-in-software-development

<div class="field field-name-body field-type-text-with-summary field-label-hidden">
<div class="field-items">
<div class="field-item even">
Economies of Scale in Software Development is about planning to be
successful.

</p>

Software development is rather cheap when compared to physical
manufacturing but that doesn't mean it doesn't cost money to create a
product.

</p>

The classic myth of the lone wolf hacker who creates a viral product
runs counter to the reality of billions of dollars generated by the
software industry.

</p>

Consider the many elements required to create a software product:

</p>

Developers (hiring, location, communication, etc.)  

Developer tools (IDE, compiler, debugger, etc.)  

QA (you do run tests of some sort, don't you?!?!)  

Distribution/Release (shrink wrapper or delivered by Internet
continuously, it still costs something)  

Support (assuming you've actually got users)

</p>

What can you do to make your software cheaper, faster, and most
importantly, better?

</p>

**1. Use Open Source**(like facebook, twitter, google). Leverage the
crowd and reduce your costs (e.g. not buying software licenses, not
paying someone to audit your software licenses, etc.)

</p>

Spending money on licenses becomes cost prohibitive for large successful
organizations.

</p>

More importantly get the quality of years of development by lots of
different perspectives. The homogeneous gets wiped out by a single
cause, get diversified!

</p>

Concerns about competitive advantage based on your supply chain (e.g.
the myth "using Open Source tools doesn't give you an edge") are
unfounded as:

</p>

\a. If your competitive advantage is a "secret supplier" then your
business will go bust as soon as anyone else finds out your secret.

</p>

\b. If you're paranoid enough to worry your competitors are messing with
your tools then you shouldn't trust a closed source vendor - keep it in
the open where everyone's watching.

</p>

Giving back to open source projects you depend on has a multiplier
effect: a healthy community project is far cheaper than paying full time
to support your critical requirements and has built in support and
marketing.

</p>

**2. Standardization**

</p>

Consider the trend of large clusters of commodity hardware. Using the
same internal development tools means it's easier to focus on the real
problems and not get lost in translation.

</p>

This doesn't mean sticking to old versions or being afraid to innovate,
but make success a formula and not an accident.

</p>

Larger efficiencies can be generated by getting a decent level of
determinism in the workflow.

</p>

This means use the same IDE, the same dependency libraries,
communication channels, etc. If you have rock stars that can't learn the
common tool or won't teach others why their method is better then you
run the risk of a dysfunctional "all-star" time bomb.

</p>

This also applies to fairness: office perks, salaries, etc. Make it an
organization about transparent achievable results, not a labyrinth of
back room exceptions.

</p>

**3. Reduced specialization (and silos)**

</p>

System Administrator's whose sole purpose is to watch machines is a
dying breed. An army of QA who manually walk through the same test plan
over and over is also legacy. Start with "DRY - Do Not Repeat Yourself".

</p>

Develop automation early and make the process simple and obvious. (i.e.
Amazon's internal conversion to API's). This also means avoiding
purchasing hardware (and the associated inventory/maintenance/overhead).
The more virtual servers you buy the larger volume discount you can
negotiate. It's not entirely about cost: 1. you're renting somebody
else's implementation of best practice 2. you need to make your product
number one, distractions from that reduce velocity.

</p>

Your feature set will continually grow. (Even with careful pruning). By
looking at software as the solution to quality/delivery/maintenance/etc.
you can reduce your running cost to a fraction of what it would be AND
be able scale up quickly when you become wildly successful.

</p>

Note: people are still irreplaceable but by having a lot more Developers
(and less unique specialists) you can distribute the load more evenly.

</p>

Getting more cross functional individuals means less silos and less
communication gaps. The network mesh effect destroys productivity if
everyone's a separate bottleneck.

</p>

**4. Make it real**

</p>

Code that lives solves problems and is valuable. Uncommitted, unused,
and otherwise un-useful code costs money to debug and deconstruct; much
worse it costs time.

</p>

Continuous integration gets your stable unit tested code some real world
bruises. Continuous deployment gets your code crunching data and making
users happy.

</p>

There will be bugs. Far more important are to ensure the product fits
the market and have the ability to quickly fix what's broken - sometimes
amputation due to business needs is critical (read how Flickr was born).

</p>

Your team must be able to execute. You lead them by example (both the
late nights and the high fives) and these real people will deliver
exponential success.

</p>
<p>
</div>
</div>
</div>
<div class="field field-name-taxonomy-vocabulary-1 field-type-taxonomy-term-reference field-label-above clearfix">
### tags:

-   [IT][]
-   [Programming][]

</div>
</p>

  [IT]: http://john-pfeiffer.com/category/it
  [Programming]: http://john-pfeiffer.com/category/tags/programming
