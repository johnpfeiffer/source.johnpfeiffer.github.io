Title: 365-4 First Real Windows Program
Date: 2010-01-18 15:05
Author: John Pfeiffer
Slug: 365-4-first-real-windows-program

<div class="field field-name-body field-type-text-with-summary field-label-hidden">
<div class="field-items">
<div class="field-item even">
Windows Programming has a steep curve in the beginning as there are many
things to memorize (oops I mean learn and understand) as theoretically
they've created the data structures and functions to get stuff on the
screen.

</p>

Again I've used gcc 2.95 windows port with the special command on my
wndclass-hello.c source code.

</p>

gcc.exe -o %1.exe %1 -Iinclude -Llib -Wall -ansi -mwindows

</p>

The code is extra commented as this is the foundation (of understanding)
for future programs.

</p>

Basically the windows program loops waiting for some input (e.g.
clicking an OK button or the X to close the window)... in the mean time
I've written a simple text in the middle. Most of the code is actually
just trying to setup the data structure of a window (there are many
options and variations that we might use later to extend our window's
functionality).

</p>
<p>
    /* john pfeiffer basic MS windows program with comments 2009-01-18 */#include           /* this includes the whole Windows API *//* Declare the Windows procedure */LRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain( HINSTANCE hThisInstance,    /* Handle to the current instance */                    HINSTANCE hPrevInstance,    /* Handle to the previous instance */                    LPSTR lpszArgument,         /* pointer to command line arguments */                    int ncmdshow)               /* show state of the window */{    HWND hwnd;               /* The handle for our window */    MSG messages;            /* Messages to the application  */    WNDCLASS wc;          /* Data structure for our defined windowclass */   wc.style = 0;    wc.lpfnWndProc = WindowProcedure;         /* This function is called by windows */   wc.cbClsExtra = 0;                        /* No extra bytes after the window class */    wc.cbWndExtra = 0;                        /* structure or the window instance */ wc.hInstance = hThisInstance;             /* handle to the owner */  wc.hIcon = NULL;                          /* no special application icon */  wc.hCursor = LoadCursor(NULL, IDC_ARROW); /* default cursor */    wc.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH);  /* the window background color */    wc.lpszMenuName = NULL;                   /* No menu */    wc.lpszClassName = "WindowsApp";        /* the name of the windows class */            /* Register the window class, if fail quit the program with an error value */    if( RegisterClass(&wc) ==0 ){ return -1;   }    /* The class is registered, let's instantiate our window */    hwnd = CreateWindowEx(           1,                   /* Extended possibilites for variation */           "WindowsApp",         /* Classname */           "Windows App",       /* Application Title Text */           WS_OVERLAPPEDWINDOW, /* default window */           CW_USEDEFAULT,       /* default x position on the screen */           CW_USEDEFAULT,       /* default y position on the screen */           CW_USEDEFAULT,       /* initial window width */           CW_USEDEFAULT,       /* initial window height */           NULL,                /* no Parent window */           NULL,                /* No menu */           hThisInstance,       /* Program Instance handler */           NULL                 /* No pointer for passing parameters */           );    ShowWindow(hwnd, ncmdshow);      /* Make the window visible on the screen */  UpdateWindow(hwnd);             /* update with changes */    /* Run the message loop. It will run until GetMessage( ) returns 0 */    while( GetMessage(&messages, NULL, 0, 0) )    {                TranslateMessage(&messages); /* Translate virtual-key messages into character messages */        DispatchMessage(&messages);  /* Send messages to WindowProcedure */    }    /* The program return-value is 0 - The value that PostQuitMessage( ) gave */    return messages.wParam;}/* This function is called by the Windows function DispatchMessage( ) */LRESULT CALLBACK WindowProcedure(                                    HWND hwnd,   /* Handle of window that received the msg */                                    UINT message,   /* The message */                                    WPARAM wParam,  /* Extra parameter (e.g. mouse x) */                                    LPARAM lParam)  /* Extra parameter (e.g. mouse y) */{   PAINTSTRUCT ps;             /* a structure for a paint job (see below */ RECT rect;                  /* a structure to hold rectangle values (e.g. x,y coordinates) */    HDC hdc;                /*handle to a DC (buffer) for the screen */    switch (message)                  /* handle the messages */    {     case WM_PAINT:           GetClientRect( hwnd, &rect );       /* get the size of our window */         hdc = BeginPaint( hwnd, &ps );      /* begin painting to the buffer */           DrawText( hdc, TEXT("Hello"), -1, &rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);            /* the above actually draws the text, h & v centered on a single line, to the buffer */          EndPaint( hwnd, &ps);            return 0;     case WM_DESTROY:         PostQuitMessage(0);        /* send a WM_QUIT to the message queue */        break;        default:                   /* for messages that we don't deal with */            return DefWindowProc(hwnd, message, wParam, lParam);    }    return 0;}/* typedef struct tagPAINTSTRUCT {  HDC  hdc;       // A handle to the display DC to be used for painting.   BOOL fErase;            //Indicates whether the background must be erased.  RECT rcPaint;            //specifies upperleft and lowerright corners where to be painted                     //in device units relative to the upper-left corner of the client area.    BOOL fRestore;  BOOL fIncUpdate;  BYTE rgbReserved[32];}PAINTSTRUCT, *PPAINTSTRUCT;*/

Whew, another day done.

</p>
<p>
</div>
</div>
</div>
</p>

